from __future__ import annotations
import socket, struct, io, time
import numpy as np
import cv2
from PySide6.QtCore import QObject, Signal, QThread

# --- Tables from your client (unchanged) ---
dc_luminance_table = bytearray([
    0x00,
    0x01, 0x05, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B
])
ac_luminance_table = bytearray([
    0x00,
    0x02, 0x01, 0x02, 0x04, 0x04, 0x03, 0x04,
    0x07, 0x05, 0x04, 0x04, 0x00, 0x01, 0x02, 0x77,
    0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21,
    0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71,
    0x13, 0x22, 0x32, 0x81, 0x08, 0x14, 0x42, 0x91,
    0xA1, 0xB1, 0xC1, 0x09, 0x23, 0x33, 0x52, 0xF0,
    0x15, 0x62, 0x72, 0xD1, 0x0A, 0x16, 0x24, 0x34,
    0xE1, 0x25, 0xF1, 0x17, 0x18, 0x19, 0x1A, 0x26,
    0x27, 0x28, 0x29, 0x2A, 0x35, 0x36, 0x37, 0x38,
    0x39, 0x3A, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,
    0x49, 0x4A, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,
    0x59, 0x5A, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
    0x69, 0x6A, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,
    0x79, 0x7A, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
    0x88, 0x89, 0x8A, 0x92, 0x93, 0x94, 0x95, 0x96,
    0x97, 0x98, 0x99, 0x9A, 0xA2, 0xA3, 0xA4, 0xA5,
    0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xB2, 0xB3, 0xB4,
    0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xC2, 0xC3,
    0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xD2,
    0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA,
    0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9,
    0xEA, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8,
    0xF9, 0xFA
])
dc_chrominance_table = bytearray([
    0x00, 0x03, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B
])
ac_chrominance_table = bytearray([
    0x00, 0x02, 0x01, 0x02, 0x04, 0x04, 0x03, 0x04, 0x07, 0x05, 0x04, 0x04, 0x00, 0x01, 0x02, 0x77,
    0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21, 0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71,
    0x13, 0x22, 0x32, 0x81, 0x08, 0x14, 0x42, 0x91, 0xA1, 0xB1, 0xC1, 0x09, 0x23, 0x33, 0x52, 0xF0,
    0x15, 0x62, 0x72, 0xD1, 0x0A, 0x16, 0x24, 0x34, 0xE1, 0x25, 0xF1, 0x17, 0x18, 0x19, 0x1A, 0x26,
    0x27, 0x28, 0x29, 0x2A, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,
    0x49, 0x4A, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
    0x69, 0x6A, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
    0x88, 0x89, 0x8A, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0xA2, 0xA3, 0xA4, 0xA5,
    0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xC2, 0xC3,
    0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA,
    0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8,
    0xF9, 0xFA
])

huffman_table = [
    0xff, 0xc4, 0x00, 0x1f, 0x00,
    0x00, 0x01, 0x05, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x01, 0x02, 0x03, 
    0x04, 0x05, 0x06, 0x07, 0x08, 
    0x09, 0x0a, 0x0b, 0xff, 0xc4, 
    0x00, 0xb5, 0x10, 0x00, 0x02, 
    0x01, 0x03, 0x03, 0x02, 0x04, 
    0x03, 0x05, 0x05, 0x04, 0x04, 
    0x00, 0x00, 0x01, 0x7d, 0x01, 
    0x02, 0x03, 0x00, 0x04, 0x11, 
    0x05, 0x12, 0x21, 0x31, 0x41, 
    0x06, 0x13, 0x51, 0x61, 0x07, 
    0x22, 0x71, 0x14, 0x32, 0x81, 0x91, 0xa1, 0x08, 0x23, 0x42, 0xb1, 0xc1, 0x15, 0x52, 0xd1, 0xf0, 0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0a, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa,
    0xff, 0xc4, 0x00, 0x1f, 0x01,
    0x00, 0x03, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,
    0xff, 0xc4, 0x00, 0xb5, 0x11,
    0x00, 0x02, 0x01, 0x02, 0x04, 0x04, 0x03, 0x04, 0x07, 0x05, 0x04, 0x04, 0x00, 0x01, 0x02, 0x77, 0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21, 0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71, 0x13, 0x22, 0x32, 0x81, 0x08, 0x14, 0x42, 0x91, 0xa1, 0xb1, 0xc1, 0x09, 0x23, 0x33, 0x52, 0xf0, 0x15, 0x62, 0x72, 0xd1, 0x0a, 0x16, 0x24, 0x34, 0xe1, 0x25, 0xf1, 0x17, 0x18, 0x19, 0x1a, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa
]

BASE_QT_LUMA = [16,11,10,16,24,40,51,61, 12,12,14,19,26,58,60,55, 14,13,16,24,40,57,69,56, 14,17,22,29,51,87,80,62, 18,22,37,56,68,109,103,77, 24,35,55,64,81,104,113,92, 49,64,78,87,103,121,120,101, 72,92,95,98,112,100,103,99]
BASE_QT_CHROMA = [17,18,24,47,99,99,99,99, 18,21,26,66,99,99,99,99, 24,26,56,99,99,99,99,99, 47,66,99,99,99,99,99,99, 99,99,99,99,99,99,99,99, 99,99,99,99,99,99,99,99, 99,99,99,99,99,99,99,99, 99,99,99,99,99,99,99,99]

def qtables_from_quality(q:int):
    q = max(1,min(99,int(q)))
    S = 5000//q if q<50 else 200-2*q
    def scale(tbl):
        out=[]
        for t in tbl:
            v=(t*S+50)//100
            out.append(1 if v<1 else (255 if v>255 else v))
        return bytes(out)
    return scale(BASE_QT_LUMA), scale(BASE_QT_CHROMA)

class RtpPacket:
    def __init__(self, data:bytes):
        self.data=data
        vpxcc, m_pt, self.sequence_number, self.timestamp, self.ssrc = struct.unpack('!BBHII', data[:12])
        self.marker=(m_pt>>7)&1
        self.payload_type=m_pt&0x7F
        off = 12 + 4*(vpxcc & 0x0F)
        if ((vpxcc>>4)&1):
            ext_profile, ext_len = struct.unpack('!HH', data[off:off+4]); off += 4 + 4*ext_len
        self.payload=data[off:]

class RtpJpegPacket(RtpPacket):
    def __init__(self, data:bytes):
        super().__init__(data)
        rp=self.payload
        self.type_specific, off3, self.frag_type, self.q, w8, h8 = struct.unpack('!B3sBBBB', rp[:8])
        self.frag_offset=int.from_bytes(off3,'big'); self.width=int(w8)*8; self.height=int(h8)*8
        p=8
        if self.q>=128:
            mbz, precision, qlen = struct.unpack('!BBH', rp[p:p+4]); p+=4
            qt = rp[p:p+qlen]; p+=qlen
            if qlen>=128:
                self.q0, self.q1 = qt[:64], qt[64:128]
            else:
                self.q0, self.q1 = qtables_from_quality(75)
        else:
            self.q0, self.q1 = qtables_from_quality(self.q if self.q>0 else 75)
        self.jpeg_data = rp[p:]

class JpegHeader:
    def __init__(self, w,h,q0,q1):
        self.buf=io.BytesIO(); self.buf.write(b'\xFF\xD8')
        self.buf.write(bytearray([0xFF,0xE0,0x00,0x10,0x4A,0x46,0x49,0x46,0x00,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00]))
        self.buf.write(b'\xFF\xDB\x00\x43\x00'); self.buf.write(bytearray(q0))
        self.buf.write(b'\xFF\xDB\x00\x43\x01'); self.buf.write(bytearray(q1))
        self.buf.write(bytes(huffman_table))
        sof = bytearray([0xFF,0xC0,0x00,0x11,0x08, *h.to_bytes(2,'big'), *w.to_bytes(2,'big'), 0x03, 0x01,0x21,0x00, 0x02,0x11,0x01, 0x03,0x11,0x01])
        self.buf.write(sof)
        self.buf.write(b'\xFF\xDA\x00\x0C\x03\x01\x00\x02\x11\x03\x11\x00\x3F\x00')
    def data(self): return self.buf.getvalue()

class JpegFrame:
    def __init__(self, first:RtpJpegPacket):
        self.hdr=JpegHeader(first.width, first.height, first.q0, first.q1)
        self.buf=bytearray(); self.last_off=0; self.ok=True; self.add(first)
    def add(self, pkt:RtpJpegPacket):
        off=pkt.frag_offset; data=pkt.jpeg_data
        if off!=self.last_off: self.ok=False
        self.last_off=off+len(data); self.buf.extend(data)
    def jpeg_bytes(self):
        out=io.BytesIO(); out.write(self.hdr.data()); out.write(self.buf); out.write(b'\xFF\xD9'); return out.getvalue()

class RtspWorker(QObject):
    frameReady = Signal(object)   # np.ndarray (BGR)
    diag = Signal(dict)           # {'fps':..., 'pkt_loss':..., 'seq_err':...}
    status = Signal(str)
    connectedChanged = Signal(bool)

    def __init__(self, rtsp_url:str, rtp_port:int=5000, flip_vertical:bool=True):
        super().__init__()
        self.rtsp_url=rtsp_url; self.server=None; self.port=None
        self.rtp_port=rtp_port; self.rtcp_port=rtp_port+1
        self.flip=flip_vertical
        self._thread=None; self._run=False
        # simple rtsp fields
        self.sock=None; self.cseq=0; self.session_id=''

    # --- RTSP helpers (minimal, like your script) ---
    def _send(self, method, uri, headers=None):
        headers=headers or {}
        req=f"{method} {uri} RTSP/1.0\r\nCSeq: {self.cseq}\r\n"
        if self.session_id:
            req+=f"Session: {self.session_id}\r\n"
        for k,v in headers.items(): req+=f"{k}: {v}\r\n"
        req+="User-Agent: PyRtsp\r\n\r\n"
        self.sock.sendall(req.encode()); self.cseq+=1
        try:
            resp=self.sock.recv(4096)
        except Exception:
            resp=b''
        return resp.decode(errors='ignore')

    def _connect(self):
        # crude parse host:port from rtsp_url
        # rtsp://HOST:PORT/...
        try:
            assert self.rtsp_url.startswith('rtsp://')
            rest=self.rtsp_url[7:]
            hostport, _path = rest.split('/',1)
            if ':' in hostport:
                host,port = hostport.split(':',1)
                port=int(port)
            else:
                host,port=hostport,554
            self.server, self.port = host, port
            self.sock=socket.create_connection((self.server,self.port), timeout=2)
            self._send('OPTIONS','*')
            self._send('DESCRIBE', self.rtsp_url, { 'Accept':'application/sdp' })
            th=f"RTP/AVP;unicast;client_port={self.rtp_port}-{self.rtcp_port}"
            self._send('SETUP', self.rtsp_url, { 'Transport': th })
            self._send('PLAY', self.rtsp_url)
            return True
        except Exception as e:
            self.status.emit(f"RTSP connect failed: {e}")
            try:
                if self.sock: self.sock.close()
            except Exception: pass
            self.sock=None
            return False

    def start(self):
        if self._thread: return
        self._run=True
        self._thread=QThread(); self.moveToThread(self._thread)
        self._thread.started.connect(self._loop)
        self._thread.start()

    def stop(self):
        self._run=False
        if self._thread:
            self._thread.quit(); self._thread.wait(500)
            self._thread=None
        try:
            if self.sock: self._send('TEARDOWN', self.rtsp_url); self.sock.close()
        except Exception: pass

    def _loop(self):
        if not self.rtsp_url:
            self.connectedChanged.emit(False)
            self.status.emit('NO VIDEO SOURCE')
            # emit placeholder frames
            t0=time.time(); frames=0
            while self._run:
                img=np.zeros((480,640,3),np.uint8)
                cv2.putText(img,'NO VIDEO',(160,240),cv2.FONT_HERSHEY_SIMPLEX,1.2,(0,0,255),3)
                self.frameReady.emit(img)
                time.sleep(1/15)
            return
        if not self._connect():
            self.connectedChanged.emit(False)
            # keep emitting placeholder
            t0=time.time()
            while self._run:
                img=np.zeros((480,640,3),np.uint8)
                cv2.putText(img,'VIDEO OFFLINE',(120,240),cv2.FONT_HERSHEY_SIMPLEX,1.0,(0,0,255),2)
                self.frameReady.emit(img); time.sleep(1/10)
            return
        self.connectedChanged.emit(True)
        # Open RTP/RTCP sockets
        rtp=socket.socket(socket.AF_INET,socket.SOCK_DGRAM); rtp.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, 1<<20)
        rtp.bind(('0.0.0.0', self.rtp_port))
        rtcp=socket.socket(socket.AF_INET,socket.SOCK_DGRAM); rtcp.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, 1<<20)
        rtcp.bind(('0.0.0.0', self.rtcp_port))

        last_ts=None; jf=None
        frames=0; t0=time.time(); seq_prev=None; seq_err=0
        while self._run:
            try:
                rtp_data,_=rtp.recvfrom(8192)
            except Exception:
                continue
            pkt=RtpJpegPacket(rtp_data)
            if seq_prev is not None and ((seq_prev+1)&0xFFFF)!=pkt.sequence_number:
                seq_err+=1
            seq_prev=pkt.sequence_number
            if pkt.payload_type!=26:
                continue
            if last_ts is None or pkt.timestamp!=last_ts or pkt.frag_offset==0:
                jf=JpegFrame(pkt); last_ts=pkt.timestamp
            else:
                if jf: jf.add(pkt)
            if pkt.marker:
                if jf and jf.ok:
                    buf=jf.jpeg_bytes()
                    frame=cv2.imdecode(np.frombuffer(buf,np.uint8), cv2.IMREAD_COLOR)
                    if frame is not None:
                        if self.flip: frame=cv2.flip(frame,0)
                        self.frameReady.emit(frame)
                        frames+=1
                        if frames%20==0:
                            fps = frames/(time.time()-t0+1e-6)
                            self.diag.emit({'fps':fps,'seq_err':seq_err})
                jf=None; last_ts=None
        try:
            rtp.close(); rtcp.close()
        except Exception: pass